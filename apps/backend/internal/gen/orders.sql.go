// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (customer_id, locale, internal_signature, delivery_service, track_number, entry, shard_key, off_shard, sm_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING order_id
`

type CreateOrderParams struct {
	CustomerID        int64  `json:"customer_id"`
	Locale            string `json:"locale"`
	InternalSignature string `json:"internal_signature"`
	DeliveryService   string `json:"delivery_service"`
	TrackNumber       string `json:"track_number"`
	Entry             string `json:"entry"`
	ShardKey          string `json:"shard_key"`
	OffShard          string `json:"off_shard"`
	SmID              int64  `json:"sm_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.CustomerID,
		arg.Locale,
		arg.InternalSignature,
		arg.DeliveryService,
		arg.TrackNumber,
		arg.Entry,
		arg.ShardKey,
		arg.OffShard,
		arg.SmID,
	)
	var order_id int64
	err := row.Scan(&order_id)
	return order_id, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT
    o.order_id,
    o.customer_id,
    o.locale,
    o.internal_signature,
    o.delivery_service,
    o.track_number,
    o.entry,
    o.shard_key,
    o.off_shard,
    o.sm_id,
    o.created_at,

    p.transaction,
    p.request_id,
    p.currency,
    p.provider,
    p.amount,
    p.payment_dt,
    p.bank,
    p.delivery_cost,
    p.goods_total,
    p.custom_fee,

    d.name,
    d.phone,
    d.zip,
    d.city,
    d.address,
    d.region,
    d.email,

    (
        SELECT json_agg(json_build_object(
            'item_id', oi.item_id,
            'chrt_id', oi.chrt_id,
            'track_number', oi.track_number,
            'price', oi.price,
            'rid', oi.rid,
            'name', oi.name,
            'sale', oi.sale,
            'size', oi.size,
            'total_price', oi.total_price,
            'nm_id', oi.nm_id,
            'brand', oi.brand,
            'status', oi.status
        ))
        FROM order_items oi
        WHERE oi.order_id = o.order_id
    ) AS items
FROM orders AS o
LEFT JOIN payments AS p ON p.order_id = o.order_id
LEFT JOIN deliveries AS d ON d.order_id = o.order_id
WHERE o.order_id = $1
`

type GetOrderByIDRow struct {
	OrderID           int64              `json:"order_id"`
	CustomerID        int64              `json:"customer_id"`
	Locale            string             `json:"locale"`
	InternalSignature string             `json:"internal_signature"`
	DeliveryService   string             `json:"delivery_service"`
	TrackNumber       string             `json:"track_number"`
	Entry             string             `json:"entry"`
	ShardKey          string             `json:"shard_key"`
	OffShard          string             `json:"off_shard"`
	SmID              int64              `json:"sm_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Transaction       *string            `json:"transaction"`
	RequestID         *string            `json:"request_id"`
	Currency          *string            `json:"currency"`
	Provider          *string            `json:"provider"`
	Amount            *int64             `json:"amount"`
	PaymentDt         *int64             `json:"payment_dt"`
	Bank              *string            `json:"bank"`
	DeliveryCost      *int64             `json:"delivery_cost"`
	GoodsTotal        *int64             `json:"goods_total"`
	CustomFee         *int64             `json:"custom_fee"`
	Name              *string            `json:"name"`
	Phone             *string            `json:"phone"`
	Zip               *string            `json:"zip"`
	City              *string            `json:"city"`
	Address           *string            `json:"address"`
	Region            *string            `json:"region"`
	Email             *string            `json:"email"`
	Items             []byte             `json:"items"`
}

func (q *Queries) GetOrderByID(ctx context.Context, orderID int64) (GetOrderByIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderByID, orderID)
	var i GetOrderByIDRow
	err := row.Scan(
		&i.OrderID,
		&i.CustomerID,
		&i.Locale,
		&i.InternalSignature,
		&i.DeliveryService,
		&i.TrackNumber,
		&i.Entry,
		&i.ShardKey,
		&i.OffShard,
		&i.SmID,
		&i.CreatedAt,
		&i.Transaction,
		&i.RequestID,
		&i.Currency,
		&i.Provider,
		&i.Amount,
		&i.PaymentDt,
		&i.Bank,
		&i.DeliveryCost,
		&i.GoodsTotal,
		&i.CustomFee,
		&i.Name,
		&i.Phone,
		&i.Zip,
		&i.City,
		&i.Address,
		&i.Region,
		&i.Email,
		&i.Items,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT
    o.order_id,
    o.customer_id,
    o.locale,
    o.internal_signature,
    o.delivery_service,
    o.track_number,
    o.entry,
    o.shard_key,
    o.off_shard,
    o.sm_id,
    o.created_at,

    p.transaction,
    p.request_id,
    p.currency,
    p.provider,
    p.amount,
    p.payment_dt,
    p.bank,
    p.delivery_cost,
    p.goods_total,
    p.custom_fee,

    d.name,
    d.phone,
    d.zip,
    d.city,
    d.address,
    d.region,
    d.email,

    (
        SELECT json_agg(json_build_object(
            'item_id', oi.item_id,
            'chrt_id', oi.chrt_id,
            'track_number', oi.track_number,
            'price', oi.price,
            'rid', oi.rid,
            'name', oi.name,
            'sale', oi.sale,
            'size', oi.size,
            'total_price', oi.total_price,
            'nm_id', oi.nm_id,
            'brand', oi.brand,
            'status', oi.status
        ))
        FROM order_items oi
        WHERE oi.order_id = o.order_id
    ) AS items
FROM orders AS o
LEFT JOIN payments AS p ON p.order_id = o.order_id
LEFT JOIN deliveries AS d ON d.order_id = o.order_id
`

type GetOrdersRow struct {
	OrderID           int64              `json:"order_id"`
	CustomerID        int64              `json:"customer_id"`
	Locale            string             `json:"locale"`
	InternalSignature string             `json:"internal_signature"`
	DeliveryService   string             `json:"delivery_service"`
	TrackNumber       string             `json:"track_number"`
	Entry             string             `json:"entry"`
	ShardKey          string             `json:"shard_key"`
	OffShard          string             `json:"off_shard"`
	SmID              int64              `json:"sm_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Transaction       *string            `json:"transaction"`
	RequestID         *string            `json:"request_id"`
	Currency          *string            `json:"currency"`
	Provider          *string            `json:"provider"`
	Amount            *int64             `json:"amount"`
	PaymentDt         *int64             `json:"payment_dt"`
	Bank              *string            `json:"bank"`
	DeliveryCost      *int64             `json:"delivery_cost"`
	GoodsTotal        *int64             `json:"goods_total"`
	CustomFee         *int64             `json:"custom_fee"`
	Name              *string            `json:"name"`
	Phone             *string            `json:"phone"`
	Zip               *string            `json:"zip"`
	City              *string            `json:"city"`
	Address           *string            `json:"address"`
	Region            *string            `json:"region"`
	Email             *string            `json:"email"`
	Items             []byte             `json:"items"`
}

func (q *Queries) GetOrders(ctx context.Context) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerID,
			&i.Locale,
			&i.InternalSignature,
			&i.DeliveryService,
			&i.TrackNumber,
			&i.Entry,
			&i.ShardKey,
			&i.OffShard,
			&i.SmID,
			&i.CreatedAt,
			&i.Transaction,
			&i.RequestID,
			&i.Currency,
			&i.Provider,
			&i.Amount,
			&i.PaymentDt,
			&i.Bank,
			&i.DeliveryCost,
			&i.GoodsTotal,
			&i.CustomFee,
			&i.Name,
			&i.Phone,
			&i.Zip,
			&i.City,
			&i.Address,
			&i.Region,
			&i.Email,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
